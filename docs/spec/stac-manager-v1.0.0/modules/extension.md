# Extension Module
## STAC Manager v1.0

**Role**: `Modifier` (Processor)

---

## 1. Purpose
Applies STAC extensions to **Items or Collections**. It uses a pluggable architecture to support both built-in extensions (like `dgeo`) and custom user-provided extensions.

## 2. Architecture
The module follows a registry-based strategy to allow both strict built-ins and flexible custom code.
- **Built-in**: Refereed by short-name (e.g., `dgeo`).
- **Custom**: Referenced by absolute Python import path (e.g., `my_lib.extensions.MyExt`).
  - *Requirement*: The package must be importable in the current environment (pip installed or PYTHONPATH).

### 2.1 ExtensionRegistry
- **Responsibility**: Maintains a mapping of short-names (e.g. `dgeo`) to Python module paths.
- **Bootstrapping**: Pre-loaded with standard supported extensions.

### 2.2 ExtensionLoader
- **Responsibility**: Dynamically imports Python modules and verifies they implement the `Extension` Protocol.
- **Caching**: Should cache loaded extension classes for performance.
- **Logic (Pseudocode)**:
  ```python
  def load_extension(self, name_or_path: str) -> Type[Extension]:
      if name_or_path in BUILTINS:
          module = import_module(BUILTINS[name_or_path])
      else:
          module = import_module(name_or_path)
          
      # Verify Protocol compliance
      ext_class = getattr(module, "CustomExtension", None)
      if irrelevant_checks(ext_class): 
           raise ValueError("Invalid Extension")
           
      return ext_class
  ```

### 2.3 ExtensionApplicator
- **Responsibility**: The worker that actually modifies the item.
- **Logic**:
    1. Checks if extension schema URI is in `stac_extensions`.
    2. Calls `extension.apply()`.
    3. Calls `extension.validate()` (if configured).

#### Applicator Pseudocode (Tier 2)

```python
def apply(self, item: pystac.Item) -> pystac.Item:
    """
    Applies the extension to the items.
    """
    # 1. Apply Logic
    item = self.extension.apply(item, self.config.config)
    
    # 2. Schema Check (Safety Net)
    if self.extension.schema_url not in item.stac_extensions:
        item.stac_extensions.append(self.extension.schema_url)
        
    # 3. Validation (Optional)
    if self.config.validate:
        is_valid, errors = self.extension.validate(item)
        if not is_valid:
            raise ExtensionError(f"Validation failed after application: {errors}")
            
    return item
```

### 2.4 Pipe Interop (Dict <-> Item)
The `ExtensionModule` implements the synchronous `Modifier` protocol:
- **Input**: Raw `dict`.
- **Process**: Internal conversion to `pystac.Item` using `pystac.Item.from_dict()`.
- **Apply**: Applies the plugin's `Extension.apply()` logic.
- **Output**: Returns the object back to the pipe via `item.to_dict()`.

### 2.5 Generic Extension Strategy
To support ad-hoc property injection without writing a custom Python class:
- **Trigger**: When `extension` is set to "generic" (or implied if `properties` are present).
- **Behavior (Pseudocode)**:

```python
def _apply_generic(self, item: dict) -> dict:
    # 1. Append Schema URI
    if self.config.schema_uri:
        schemas = item.setdefault("stac_extensions", [])
        if self.config.schema_uri not in schemas:
            schemas.append(self.config.schema_uri)

    # 2. Merge Properties (Shallow Update)
    if self.config.properties:
        props = item.setdefault("properties", {})
        props.update(self.config.properties) # Overwrites existing keys
        
    return item
```

## 3. Configuration Schema

```python
from pydantic import BaseModel, Field
from typing import Dict, Any

class ExtensionConfig(BaseModel):
    extension: str # Built-in name, python path, or "generic"
    config: Dict[str, Any] = Field(default_factory=dict) # Extension-specific config
    schema_uri: Optional[str] = None # For "generic" mode
    properties: Dict[str, Any] = None # For "generic" mode; merges into item properties
    validate: bool = False # Whether to run validation after application
```

### 3.1 Example Usage (YAML)

```yaml
- id: apply_dgeo
  module: ExtensionModule
  config:
    extension: "dgeo"
    config:
      ownership:
        did: "did:key:z6Mk..."
        type: "individual"
      licensing:
        license: "CC-BY-4.0"
```

## 4. I/O Contract

**Input (Workflow Context)**:
- Items from previous step.

**Output (Python)**:
```python
def modify(self, item: dict, context: WorkflowContext) -> dict | None:
    """
    Applies STAC extensions to the item dictionary.
    """
```

## 5. Built-in Extensions
### dgeo
- **Schema**: DecentralizedGeo Asset schema.
- **Fields**: `dgeo:ownership`, `dgeo:provenance`.

### alternate-assets
- **Schema**: Alternate Assets extension.
- **Fields**: `alternate`: { "s3": ... } in assets.

## 6. Error Handling
- **Load Error**: Fail fast if extension module cannot be found.
- **Apply Error**: Log warning and skip Item if extension logic fails.
- **Validation Error**: Generated by the extension's `validate()` method; leads to item rejection.
